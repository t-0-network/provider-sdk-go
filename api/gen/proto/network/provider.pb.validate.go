// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: network/provider.proto

package network

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AppendLedgerEntriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppendLedgerEntriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendLedgerEntriesRequestMultiError, or nil if none found.
func (m *AppendLedgerEntriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequestValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AppendLedgerEntriesRequestMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequestMultiError is an error wrapping multiple
// validation errors returned by AppendLedgerEntriesRequest.ValidateAll() if
// the designated constraints aren't met.
type AppendLedgerEntriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequestMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequestValidationError is the validation error returned
// by AppendLedgerEntriesRequest.Validate if the designated constraints aren't met.
type AppendLedgerEntriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendLedgerEntriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequestValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequestValidationError{}

// Validate checks the field values on AppendLedgerEntriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppendLedgerEntriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendLedgerEntriesResponseMultiError, or nil if none found.
func (m *AppendLedgerEntriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AppendLedgerEntriesResponseMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesResponseMultiError is an error wrapping multiple
// validation errors returned by AppendLedgerEntriesResponse.ValidateAll() if
// the designated constraints aren't met.
type AppendLedgerEntriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesResponseMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesResponseValidationError is the validation error returned
// by AppendLedgerEntriesResponse.Validate if the designated constraints
// aren't met.
type AppendLedgerEntriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendLedgerEntriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesResponseValidationError) ErrorName() string {
	return "AppendLedgerEntriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesResponseValidationError{}

// Validate checks the field values on PayoutRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayoutRequestMultiError, or
// nil if none found.
func (m *PayoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PayoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentId

	// no validation rules for PayoutId

	// no validation rules for Currency

	// no validation rules for ClientQuoteId

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayoutRequestValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayoutRequestValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayoutRequestValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayoutMethod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayoutRequestValidationError{
					field:  "PayoutMethod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayoutRequestValidationError{
					field:  "PayoutMethod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutMethod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayoutRequestValidationError{
				field:  "PayoutMethod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PayoutRequestMultiError(errors)
	}

	return nil
}

// PayoutRequestMultiError is an error wrapping multiple validation errors
// returned by PayoutRequest.ValidateAll() if the designated constraints
// aren't met.
type PayoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayoutRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayoutRequestMultiError) AllErrors() []error { return m }

// PayoutRequestValidationError is the validation error returned by
// PayoutRequest.Validate if the designated constraints aren't met.
type PayoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayoutRequestValidationError) ErrorName() string { return "PayoutRequestValidationError" }

// Error satisfies the builtin error interface
func (e PayoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayoutRequestValidationError{}

// Validate checks the field values on PayoutResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayoutResponseMultiError,
// or nil if none found.
func (m *PayoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PayoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PayoutResponseMultiError(errors)
	}

	return nil
}

// PayoutResponseMultiError is an error wrapping multiple validation errors
// returned by PayoutResponse.ValidateAll() if the designated constraints
// aren't met.
type PayoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayoutResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayoutResponseMultiError) AllErrors() []error { return m }

// PayoutResponseValidationError is the validation error returned by
// PayoutResponse.Validate if the designated constraints aren't met.
type PayoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayoutResponseValidationError) ErrorName() string { return "PayoutResponseValidationError" }

// Error satisfies the builtin error interface
func (e PayoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayoutResponseValidationError{}

// Validate checks the field values on UpdatePaymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePaymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePaymentRequestMultiError, or nil if none found.
func (m *UpdatePaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentClientId

	switch v := m.Result.(type) {
	case *UpdatePaymentRequest_Success_:
		if v == nil {
			err := UpdatePaymentRequestValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSuccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePaymentRequestValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePaymentRequestValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePaymentRequestValidationError{
					field:  "Success",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UpdatePaymentRequest_Failure_:
		if v == nil {
			err := UpdatePaymentRequestValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFailure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePaymentRequestValidationError{
						field:  "Failure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePaymentRequestValidationError{
						field:  "Failure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFailure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePaymentRequestValidationError{
					field:  "Failure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return UpdatePaymentRequestMultiError(errors)
	}

	return nil
}

// UpdatePaymentRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePaymentRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePaymentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePaymentRequestMultiError) AllErrors() []error { return m }

// UpdatePaymentRequestValidationError is the validation error returned by
// UpdatePaymentRequest.Validate if the designated constraints aren't met.
type UpdatePaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePaymentRequestValidationError) ErrorName() string {
	return "UpdatePaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePaymentRequestValidationError{}

// Validate checks the field values on UpdatePaymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePaymentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePaymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePaymentResponseMultiError, or nil if none found.
func (m *UpdatePaymentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePaymentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePaymentResponseMultiError(errors)
	}

	return nil
}

// UpdatePaymentResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePaymentResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePaymentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePaymentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePaymentResponseMultiError) AllErrors() []error { return m }

// UpdatePaymentResponseValidationError is the validation error returned by
// UpdatePaymentResponse.Validate if the designated constraints aren't met.
type UpdatePaymentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePaymentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePaymentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePaymentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePaymentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePaymentResponseValidationError) ErrorName() string {
	return "UpdatePaymentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePaymentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePaymentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePaymentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePaymentResponseValidationError{}

// Validate checks the field values on UpdateLimitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLimitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLimitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLimitRequestMultiError, or nil if none found.
func (m *UpdateLimitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLimitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for ProviderId

	if all {
		switch v := interface{}(m.GetPayoutLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "PayoutLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "PayoutLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLimitRequestValidationError{
				field:  "PayoutLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreditLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "CreditLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "CreditLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreditLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLimitRequestValidationError{
				field:  "CreditLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreditUsage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "CreditUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLimitRequestValidationError{
					field:  "CreditUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreditUsage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLimitRequestValidationError{
				field:  "CreditUsage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateLimitRequestMultiError(errors)
	}

	return nil
}

// UpdateLimitRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateLimitRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLimitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLimitRequestMultiError) AllErrors() []error { return m }

// UpdateLimitRequestValidationError is the validation error returned by
// UpdateLimitRequest.Validate if the designated constraints aren't met.
type UpdateLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLimitRequestValidationError) ErrorName() string {
	return "UpdateLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLimitRequestValidationError{}

// Validate checks the field values on UpdateLimitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLimitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLimitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLimitResponseMultiError, or nil if none found.
func (m *UpdateLimitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLimitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateLimitResponseMultiError(errors)
	}

	return nil
}

// UpdateLimitResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateLimitResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateLimitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLimitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLimitResponseMultiError) AllErrors() []error { return m }

// UpdateLimitResponseValidationError is the validation error returned by
// UpdateLimitResponse.Validate if the designated constraints aren't met.
type UpdateLimitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLimitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLimitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLimitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLimitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLimitResponseValidationError) ErrorName() string {
	return "UpdateLimitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLimitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLimitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLimitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLimitResponseValidationError{}

// Validate checks the field values on CreatePayInDetailsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayInDetailsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayInDetailsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayInDetailsRequestMultiError, or nil if none found.
func (m *CreatePayInDetailsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayInDetailsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentIntentId

	if all {
		switch v := interface{}(m.GetSender()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePayInDetailsRequestValidationError{
					field:  "Sender",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePayInDetailsRequestValidationError{
					field:  "Sender",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSender()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePayInDetailsRequestValidationError{
				field:  "Sender",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePayInDetailsRequestMultiError(errors)
	}

	return nil
}

// CreatePayInDetailsRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePayInDetailsRequest.ValidateAll() if the
// designated constraints aren't met.
type CreatePayInDetailsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayInDetailsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayInDetailsRequestMultiError) AllErrors() []error { return m }

// CreatePayInDetailsRequestValidationError is the validation error returned by
// CreatePayInDetailsRequest.Validate if the designated constraints aren't met.
type CreatePayInDetailsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayInDetailsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayInDetailsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayInDetailsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayInDetailsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayInDetailsRequestValidationError) ErrorName() string {
	return "CreatePayInDetailsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayInDetailsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayInDetailsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayInDetailsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayInDetailsRequestValidationError{}

// Validate checks the field values on CreatePayInDetailsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayInDetailsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayInDetailsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayInDetailsResponseMultiError, or nil if none found.
func (m *CreatePayInDetailsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayInDetailsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPayInMethod() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatePayInDetailsResponseValidationError{
						field:  fmt.Sprintf("PayInMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatePayInDetailsResponseValidationError{
						field:  fmt.Sprintf("PayInMethod[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatePayInDetailsResponseValidationError{
					field:  fmt.Sprintf("PayInMethod[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreatePayInDetailsResponseMultiError(errors)
	}

	return nil
}

// CreatePayInDetailsResponseMultiError is an error wrapping multiple
// validation errors returned by CreatePayInDetailsResponse.ValidateAll() if
// the designated constraints aren't met.
type CreatePayInDetailsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayInDetailsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayInDetailsResponseMultiError) AllErrors() []error { return m }

// CreatePayInDetailsResponseValidationError is the validation error returned
// by CreatePayInDetailsResponse.Validate if the designated constraints aren't met.
type CreatePayInDetailsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayInDetailsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayInDetailsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayInDetailsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayInDetailsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayInDetailsResponseValidationError) ErrorName() string {
	return "CreatePayInDetailsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayInDetailsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayInDetailsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayInDetailsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayInDetailsResponseValidationError{}

// Validate checks the field values on AppendLedgerEntriesRequest_Transaction
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// AppendLedgerEntriesRequest_TransactionMultiError, or nil if none found.
func (m *AppendLedgerEntriesRequest_Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.TransactionDetails.(type) {
	case *AppendLedgerEntriesRequest_Transaction_PayIn_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPayIn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPayIn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "PayIn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AppendLedgerEntriesRequest_Transaction_PayoutReservation_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPayoutReservation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayoutReservation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayoutReservation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPayoutReservation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "PayoutReservation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AppendLedgerEntriesRequest_Transaction_Payout_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPayout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "Payout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "Payout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPayout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AppendLedgerEntriesRequest_Transaction_ProviderSettlement_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProviderSettlement()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "ProviderSettlement",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "ProviderSettlement",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProviderSettlement()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "ProviderSettlement",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AppendLedgerEntriesRequest_Transaction_FeeSettlement_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFeeSettlement()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "FeeSettlement",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "FeeSettlement",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFeeSettlement()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "FeeSettlement",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease_:
		if v == nil {
			err := AppendLedgerEntriesRequest_TransactionValidationError{
				field:  "TransactionDetails",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPayoutReservationRelease()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayoutReservationRelease",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendLedgerEntriesRequest_TransactionValidationError{
						field:  "PayoutReservationRelease",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPayoutReservationRelease()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendLedgerEntriesRequest_TransactionValidationError{
					field:  "PayoutReservationRelease",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_TransactionMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_TransactionMultiError is an error wrapping
// multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction.ValidateAll() if the designated
// constraints aren't met.
type AppendLedgerEntriesRequest_TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_TransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_TransactionMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequest_TransactionValidationError is the validation
// error returned by AppendLedgerEntriesRequest_Transaction.Validate if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesRequest_TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_TransactionValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_TransactionValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_TransactionValidationError{}

// Validate checks the field values on AppendLedgerEntriesRequest_LedgerEntry
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AppendLedgerEntriesRequest_LedgerEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_LedgerEntry with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// AppendLedgerEntriesRequest_LedgerEntryMultiError, or nil if none found.
func (m *AppendLedgerEntriesRequest_LedgerEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_LedgerEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountOwnerId

	// no validation rules for AccountType

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetDebit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "Debit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "Debit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppendLedgerEntriesRequest_LedgerEntryValidationError{
				field:  "Debit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCredit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "Credit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "Credit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCredit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppendLedgerEntriesRequest_LedgerEntryValidationError{
				field:  "Credit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExchangeRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "ExchangeRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppendLedgerEntriesRequest_LedgerEntryValidationError{
					field:  "ExchangeRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppendLedgerEntriesRequest_LedgerEntryValidationError{
				field:  "ExchangeRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_LedgerEntryMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_LedgerEntryMultiError is an error wrapping
// multiple validation errors returned by
// AppendLedgerEntriesRequest_LedgerEntry.ValidateAll() if the designated
// constraints aren't met.
type AppendLedgerEntriesRequest_LedgerEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_LedgerEntryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_LedgerEntryMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequest_LedgerEntryValidationError is the validation
// error returned by AppendLedgerEntriesRequest_LedgerEntry.Validate if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_LedgerEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_LedgerEntryValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_LedgerEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_LedgerEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_LedgerEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_LedgerEntryValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_PayIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayIn with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_PayInMultiError, or nil if none found.
func (m *AppendLedgerEntriesRequest_Transaction_PayIn) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_PayIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_PayInMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_PayInMultiError is an error wrapping
// multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_PayIn.ValidateAll() if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_PayInMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_PayInMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequest_Transaction_PayInValidationError is the
// validation error returned by
// AppendLedgerEntriesRequest_Transaction_PayIn.Validate if the designated
// constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_PayInValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_PayInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_PayIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_PayInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_PayInValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayoutReservation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayoutReservation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError, or nil
// if none found.
func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservation) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError is an
// error wrapping multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_PayoutReservation.ValidateAll() if
// the designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_PayoutReservationMultiError) AllErrors() []error {
	return m
}

// AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError is
// the validation error returned by
// AppendLedgerEntriesRequest_Transaction_PayoutReservation.Validate if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_PayoutReservation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_PayoutReservationValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_Payout with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_Payout) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_Payout with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_PayoutMultiError, or nil if none found.
func (m *AppendLedgerEntriesRequest_Transaction_Payout) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_Payout) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_PayoutMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_PayoutMultiError is an error wrapping
// multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_Payout.ValidateAll() if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_PayoutMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_PayoutMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequest_Transaction_PayoutValidationError is the
// validation error returned by
// AppendLedgerEntriesRequest_Transaction_Payout.Validate if the designated
// constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_PayoutValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_PayoutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_Payout.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_PayoutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_PayoutValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_ProviderSettlement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_ProviderSettlement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_ProviderSettlement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError, or nil
// if none found.
func (m *AppendLedgerEntriesRequest_Transaction_ProviderSettlement) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_ProviderSettlement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SettlementId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError is an
// error wrapping multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_ProviderSettlement.ValidateAll() if
// the designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_ProviderSettlementMultiError) AllErrors() []error {
	return m
}

// AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError is
// the validation error returned by
// AppendLedgerEntriesRequest_Transaction_ProviderSettlement.Validate if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_ProviderSettlement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_ProviderSettlementValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_FeeSettlement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_FeeSettlement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_FeeSettlement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError, or nil if
// none found.
func (m *AppendLedgerEntriesRequest_Transaction_FeeSettlement) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_FeeSettlement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FeeSettlementId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError is an error
// wrapping multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_FeeSettlement.ValidateAll() if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_FeeSettlementMultiError) AllErrors() []error { return m }

// AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError is the
// validation error returned by
// AppendLedgerEntriesRequest_Transaction_FeeSettlement.Validate if the
// designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_FeeSettlement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_FeeSettlementValidationError{}

// Validate checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError,
// or nil if none found.
func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentId

	if len(errors) > 0 {
		return AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError(errors)
	}

	return nil
}

// AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError is
// an error wrapping multiple validation errors returned by
// AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease.ValidateAll()
// if the designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseMultiError) AllErrors() []error {
	return m
}

// AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError
// is the validation error returned by
// AppendLedgerEntriesRequest_Transaction_PayoutReservationRelease.Validate if
// the designated constraints aren't met.
type AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) ErrorName() string {
	return "AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError"
}

// Error satisfies the builtin error interface
func (e AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendLedgerEntriesRequest_Transaction_PayoutReservationRelease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendLedgerEntriesRequest_Transaction_PayoutReservationReleaseValidationError{}

// Validate checks the field values on UpdatePaymentRequest_Success with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePaymentRequest_Success) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePaymentRequest_Success with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePaymentRequest_SuccessMultiError, or nil if none found.
func (m *UpdatePaymentRequest_Success) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePaymentRequest_Success) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPayoutAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePaymentRequest_SuccessValidationError{
					field:  "PayoutAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePaymentRequest_SuccessValidationError{
					field:  "PayoutAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePaymentRequest_SuccessValidationError{
				field:  "PayoutAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaidOutAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePaymentRequest_SuccessValidationError{
					field:  "PaidOutAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePaymentRequest_SuccessValidationError{
					field:  "PaidOutAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaidOutAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePaymentRequest_SuccessValidationError{
				field:  "PaidOutAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePaymentRequest_SuccessMultiError(errors)
	}

	return nil
}

// UpdatePaymentRequest_SuccessMultiError is an error wrapping multiple
// validation errors returned by UpdatePaymentRequest_Success.ValidateAll() if
// the designated constraints aren't met.
type UpdatePaymentRequest_SuccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePaymentRequest_SuccessMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePaymentRequest_SuccessMultiError) AllErrors() []error { return m }

// UpdatePaymentRequest_SuccessValidationError is the validation error returned
// by UpdatePaymentRequest_Success.Validate if the designated constraints
// aren't met.
type UpdatePaymentRequest_SuccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePaymentRequest_SuccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePaymentRequest_SuccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePaymentRequest_SuccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePaymentRequest_SuccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePaymentRequest_SuccessValidationError) ErrorName() string {
	return "UpdatePaymentRequest_SuccessValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePaymentRequest_SuccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePaymentRequest_Success.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePaymentRequest_SuccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePaymentRequest_SuccessValidationError{}

// Validate checks the field values on UpdatePaymentRequest_Failure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePaymentRequest_Failure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePaymentRequest_Failure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePaymentRequest_FailureMultiError, or nil if none found.
func (m *UpdatePaymentRequest_Failure) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePaymentRequest_Failure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePaymentRequest_FailureMultiError(errors)
	}

	return nil
}

// UpdatePaymentRequest_FailureMultiError is an error wrapping multiple
// validation errors returned by UpdatePaymentRequest_Failure.ValidateAll() if
// the designated constraints aren't met.
type UpdatePaymentRequest_FailureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePaymentRequest_FailureMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePaymentRequest_FailureMultiError) AllErrors() []error { return m }

// UpdatePaymentRequest_FailureValidationError is the validation error returned
// by UpdatePaymentRequest_Failure.Validate if the designated constraints
// aren't met.
type UpdatePaymentRequest_FailureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePaymentRequest_FailureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePaymentRequest_FailureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePaymentRequest_FailureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePaymentRequest_FailureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePaymentRequest_FailureValidationError) ErrorName() string {
	return "UpdatePaymentRequest_FailureValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePaymentRequest_FailureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePaymentRequest_Failure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePaymentRequest_FailureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePaymentRequest_FailureValidationError{}

// Validate checks the field values on CreatePayInDetailsRequest_Sender with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreatePayInDetailsRequest_Sender) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayInDetailsRequest_Sender with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreatePayInDetailsRequest_SenderMultiError, or nil if none found.
func (m *CreatePayInDetailsRequest_Sender) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayInDetailsRequest_Sender) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Sender.(type) {
	case *CreatePayInDetailsRequest_Sender_PrivatePerson_:
		if v == nil {
			err := CreatePayInDetailsRequest_SenderValidationError{
				field:  "Sender",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrivatePerson()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatePayInDetailsRequest_SenderValidationError{
						field:  "PrivatePerson",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatePayInDetailsRequest_SenderValidationError{
						field:  "PrivatePerson",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrivatePerson()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatePayInDetailsRequest_SenderValidationError{
					field:  "PrivatePerson",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CreatePayInDetailsRequest_SenderMultiError(errors)
	}

	return nil
}

// CreatePayInDetailsRequest_SenderMultiError is an error wrapping multiple
// validation errors returned by
// CreatePayInDetailsRequest_Sender.ValidateAll() if the designated
// constraints aren't met.
type CreatePayInDetailsRequest_SenderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayInDetailsRequest_SenderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayInDetailsRequest_SenderMultiError) AllErrors() []error { return m }

// CreatePayInDetailsRequest_SenderValidationError is the validation error
// returned by CreatePayInDetailsRequest_Sender.Validate if the designated
// constraints aren't met.
type CreatePayInDetailsRequest_SenderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayInDetailsRequest_SenderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayInDetailsRequest_SenderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayInDetailsRequest_SenderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayInDetailsRequest_SenderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayInDetailsRequest_SenderValidationError) ErrorName() string {
	return "CreatePayInDetailsRequest_SenderValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayInDetailsRequest_SenderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayInDetailsRequest_Sender.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayInDetailsRequest_SenderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayInDetailsRequest_SenderValidationError{}

// Validate checks the field values on
// CreatePayInDetailsRequest_Sender_PrivatePerson with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePayInDetailsRequest_Sender_PrivatePerson) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreatePayInDetailsRequest_Sender_PrivatePerson with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreatePayInDetailsRequest_Sender_PrivatePersonMultiError, or nil if none found.
func (m *CreatePayInDetailsRequest_Sender_PrivatePerson) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayInDetailsRequest_Sender_PrivatePerson) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PrivatePersonId

	if len(errors) > 0 {
		return CreatePayInDetailsRequest_Sender_PrivatePersonMultiError(errors)
	}

	return nil
}

// CreatePayInDetailsRequest_Sender_PrivatePersonMultiError is an error
// wrapping multiple validation errors returned by
// CreatePayInDetailsRequest_Sender_PrivatePerson.ValidateAll() if the
// designated constraints aren't met.
type CreatePayInDetailsRequest_Sender_PrivatePersonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayInDetailsRequest_Sender_PrivatePersonMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayInDetailsRequest_Sender_PrivatePersonMultiError) AllErrors() []error { return m }

// CreatePayInDetailsRequest_Sender_PrivatePersonValidationError is the
// validation error returned by
// CreatePayInDetailsRequest_Sender_PrivatePerson.Validate if the designated
// constraints aren't met.
type CreatePayInDetailsRequest_Sender_PrivatePersonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) ErrorName() string {
	return "CreatePayInDetailsRequest_Sender_PrivatePersonValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayInDetailsRequest_Sender_PrivatePersonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayInDetailsRequest_Sender_PrivatePerson.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayInDetailsRequest_Sender_PrivatePersonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayInDetailsRequest_Sender_PrivatePersonValidationError{}
